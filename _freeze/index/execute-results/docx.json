{
  "hash": "699f1da6496a5423e69e9d0a6645d0df",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Economic Complexity of Australian Regions\nauthor:\n  - name: Hamish Gamble\n    orcid: 0000-0003-1277-1227\n    corresponding: true\n    email: hamish.gamble@flinders.edu.au\n    affiliations:\n      - Flinders University\n  - name: Sharif Rasel\n    orcid: \n    corresponding: false\n    roles: []\n    affiliations:\n      - Flinders University\nkeywords:\n  - Economic Complexity\n  - Advanced Manufacturing\nabstract: |\nplain-language-summary: |\nkey-points:\ndate: last-modified\nbibliography: references.bib\ncitation:\n  container-title: |\nnumber-sections: true\n---\n\n\n\n\n\n\n## Introduction\n\n## Literature Review\n\n@hidalgo2009 introduced the concept of economic complexity as a means of quantifying and explaining differences in the economic development trajectory of different countries. Their method used bilateral trade data to identify the network structure of countries and the products they export and built on the concept of relatedness introduced in @hidalgo2007. Economic complexity has been shown to be predictor of\n\nRelatedness has since been applied across industry [@neffke2012], research areas [@guevara2016], occupation [@muneepeerakul2013] and technology (patents) [@kogler2013].\n\nThe relatedness approach has also been used to quantify economic complexity across cities, states, and regions, using employment data[@ecus; \\@ecnz; @ecmexico], business counts[@ecchina], patent classifications [@balland2021], and interstate and international trade data [@ecaus].\n\nDespite differences in data sources, the method for calculating economic complexity in the literature is relatively standard. The presence of an activity in a region is often identified using a location quotient method, such that an activity is said to be present in a region if:\n\n$$\\frac{X_a^r/\\sum_{a}X_a^r}{\\sum_{r}X_a^r/\\sum_{r,a}X_a^r} \\geq 1$$\n\nWhere $X$ is the measure of an activity $a$ in region $r$ - such as the level of employment in an occupation in a city, or the number of businesses classified in an industry in a province, or the value of exports of a product from a country. The location quotient method creates a binary matrix $M$ with $a$ rows and $r$ columns.\n\n-   In a study of the economic complexity of US regions, @ecus use metropolitan areas as the basis for calculations.\n-   Metropolitan areas in the United States are defined such that jobs within a given area are held by residents who live in that area.\n-   Metropolitan areas have a population of at least 50,000 people. The smallest MSA was estimated to have a 2023 population of 57,700 (about 0.015% of US population).\n-   \n\n### Small (n) areas\n\n-   In New Zealand, @ecnz use weighted correlations of local employment shares. Regions range from a population of 1,434 to 573,150 with a mean population of 29,947 and median population of 6,952. Employment is measured as an industry-occupation pair.\n\n-   @hidalgo2007 and others have focused on the co-occurrence of revealed comparative advantage indices, derived from a location quotient. The location quotient is measured as:\n\n    $$\n    LQ = \\frac{X_r^a/X_r}{X^a/X}\n    $$\n\n-   As such, small values of $\\frac{X^a}{X}$ can exacerbate any measurement error in the numerator. Additionally, the binary nature of measuring revealed comparative advantage when the location quotient is greater than 1, results in a discontinuity at $LQ = 1$.\n\n-   Differences in relationship between complexity and relatedness on indicators may be entirely context dependent.\n\n## Data & Methods {#sec-data-methods}\n\n### Data\n\n-   Calculate economic complexity indicators for Australian regions using employment data from the 2021 Census.\n\n-   Regions classified by Statistical Areas Level 3 (SA3)\n\n-   Economic activity classified by ANZSIC industry division and ANZSCO major group\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'tidyverse' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'ggplot2' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'tibble' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'tidyr' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'readr' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'purrr' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'dplyr' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'stringr' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'forcats' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'lubridate' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nlibrary(strayr)\nlibrary(economiccomplexity)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'economiccomplexity' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n\nAttaching package: 'economiccomplexity'\n\nThe following object is masked from 'package:stats':\n\n    density\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nlibrary(sf)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'sf' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nLinking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.3.1; sf_use_s2() is TRUE\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nlibrary(tmap)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n\nAttaching package: 'tmap'\n\nThe following object is masked from 'package:datasets':\n\n    rivers\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nlibrary(spdep)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'spdep' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nLoading required package: spData\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: package 'spData' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nTo access larger datasets in this package, install the spDataLarge\npackage with: `install.packages('spDataLarge',\nrepos='https://nowosad.github.io/drat/', type='source')`\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\npow <- read_csv(\"data/sa3-pow-occp-indp-1-digit.csv\",\n                skip = 9,\n                n_max = 99360,\n                col_select = c(sa3 = \"SA3 (POW)\",\n                               anzsic_division = \"1-digit level INDP Industry of Employment\",\n                               anzsco_major = \"1-digit level OCCP Occupation\",\n                               count = Count)) |> \n  filter(!anzsic_division %in% c(\"Inadequately described\", \"Not stated\",\n                                 \"Not applicable\", \"Total\"),\n         !anzsco_major %in% c(\"Inadequately described\", \"Not stated\",\n                              \"Not applicable\", \"Total\"),\n         sa3 != \"Total\")\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nNew names:\n• `` -> `...6`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat <- vroom(...)\n  problems(dat)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nRows: 99360 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): 1-digit level OCCP Occupation, SA3 (POW), 1-digit level INDP Indust...\ndbl (1): Count\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nregions <- pow |> \n  group_by(x = str_detect(sa3, \"POW|Migratory\")) |>  \n  summarise(count = sum(count)) |> \n  mutate(p = count/sum(count),\n         x = ifelse(!x, \"included\", \"excluded\")) |> \n  split(f = ~x)\n\npow_clean <- pow |> \n  filter(!str_detect(sa3, \"POW|Migratory\")) |> \n  mutate(anzsic_division = fct_inorder(anzsic_division),\n         anzsco_major = fct_inorder(anzsco_major), \n         industry_occupation = paste0(anzsic_division, \" (\", anzsco_major,\")\"),\n         industry_occupation = fct_inorder(industry_occupation)) |> \n  group_by(sa3, industry_occupation) |> \n  summarise(count = sum(count),\n            .groups = \"drop\") |> \n  group_by(sa3) |> \n  mutate(sa3_size = sum(count)) |> \n  ungroup() |> \n  group_by(industry_occupation) |> \n  mutate(industry_occupation_size = sum(count)) |> \n  ungroup()\n```\n:::\n\n\n\n\n\n\n-   We exclude individuals who identify their place of work as a Migratory - Offshore - Shipping region or as No Fixed Address. Employment in these regions totals 497,913 or about 4% of the total sample.\n\n-   Following @ecnz, employment is aggregated into industry-occupation pairs, allowing for differentiation between, for example, managers working in agriculture, forestry, and fishing, and managers working in retail trade.\n\n-   Dataset covers 340 regions and 152 industry-occupations. @fig-employment-density shows the presence of any level of employment within a region and industry-occupation. As can be seen, there is a high level of employment density across our data.\n\n\n\n\n\n\n::: {#cell-fig-employment-density .cell}\n\n```{.r .cell-code .hidden}\npow_clean |> \n  mutate(presence = count > 0) |> \n  ggplot(aes(x = reorder(sa3, -sa3_size),\n             y = reorder(industry_occupation, -industry_occupation_size),\n             fill = presence)) +\n  geom_raster() +\n  labs(x = \"Region\",\n       y = \"Industry-Occupation\") +\n  scale_fill_manual(breaks = c(TRUE, FALSE),\n                    values = c(\"#3182db\", \"white\")) + \n  theme(axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        panel.border = element_rect(fill = NA),\n        legend.position = \"none\") + \n  coord_equal()\n```\n\n::: {.cell-output-display}\n![Presence of employment across regions and industry-occupations.](index_files/figure-docx/fig-employment-density-1.png){#fig-employment-density}\n:::\n:::\n\n\n\n\n\n\n### Method\n\nThis section follows the method of @ecnz using correlations of employment shares rather than a location quotient method.\n\n#### Relatedness\n\nActivities are related based on the weighted correlation between the local activity share of employment, weighted by each regions share of total employment.\n\n-   First calculate the weighted covariance\n\n$$\ncov_{aa} = \\sum_{c \\in C} (\\frac{E_c^{a_i}}{E_c}-\\frac{E^{a_i}}{E})(\\frac{E_c^{a_j}}{E_c}-\\frac{E^{a_j}}{E})\n$$\n\n-   Divide the weighted covariance by the city share-weighted standard deviations of the local activity shares to get the weighted correlation.\n\n-   Map the correlation to the interval $[0,1]$ such that:\n\n    $$\n    r_{aa} = \\frac{1}{2}(cor(a_i, a_j) + 1)\n    $$\n\nCity relatedness is calculated symmetrically such that:\n\n$$\nr_{cc} = \\frac{1}{2}(cor(c_i, c_j) + 1)\n$$\n\n#### Complexity\n\nActivity complexity is defined by the second eigenvector of the matrix $r_{aa}$ and city complexity is defined by the second eigenvector of the matrix $r_{cc}$. The sign of activity complexity is set such that it is positively correlated with the weighted mean size of cities that contain activity $a$, and the sign of city complexity is set such that it is positively correlated with the local share-weighted mean complexity of activities in city $c$\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# function to calculate complexity from a region * activity matrix m\n\ncomplexity_nz <- function(m, base_data) {\n  \n  activity_share <- m / rowSums(m)\n  national_share_employment <- rowSums(m) / sum(m)\n  \n  # Relatedness of activities is the weighted covariance between the local share vectors for activities i and j, \n  # weighted by each regions share of total employment.\n  \n  \n  r_aa <- 0.5*(cov.wt(x = activity_share, wt = national_share_employment, cor = TRUE)$cor + 1)\n  \n  \n  #Complexity of activity a is the element a of the standardized second eigenvector of the row-standardized relatedness matrix r.\n  complexity <- list()\n  complexity$activity <- Re(eigen(r_aa/rowSums(r_aa))$vector[,2])\n  complexity$activity  <- (complexity$activity  - mean(complexity$activity ))/sd(complexity$activity)\n  names(complexity$activity) <- colnames(m)\n  \n  #Complexity is positively correlated with the weighted mean size of cities that contain activity a\n  wmsc <- colSums(m/colSums(m)*rowSums(m))\n  \n  if (cor(complexity$activity , wmsc) < 0) {\n    complexity$activity  = -1*complexity$activity\n  } else complexity$activity  = complexity$activity \n  \n  message(glue::glue(\"most complex activity: {names(complexity$activity[complexity$activity == max(complexity$activity)])}\")) \n  \n  \n  # Relatedness of cities is symmetric to activities.\n  city_share <- t(m / rowSums(m))\n  national_share_activity <- colSums(m)/sum(m)\n  r_cc <- 0.5*(cov.wt(x = city_share, wt = national_share_activity, cor = TRUE)$cor + 1)\n  \n  complexity$city <- Re(eigen(r_cc/rowSums(r_cc))$vector[,2])\n  complexity$city <- (complexity$city- mean(complexity$city))/sd(complexity$city)\n  names(complexity$city) <- rownames(m)\n  \n  #City complexity is positively correlated with the local share weighted mean complexity of activities in city c.\n  wmc <- rowSums(m/colSums(m)*complexity$activity)\n  \n  if (cor(complexity$city, wmc) < 0 || complexity$city[\"Brisbane Inner\"] < 0) {\n    complexity$city = -1 * complexity$city\n    } else complexity$city = complexity$city\n  \n  message(glue::glue(\"most complex city: {names(complexity$city[complexity$city == max(complexity$city)])}\")) \n  \n  df.complexity <- inner_join(base_data, enframe(complexity$city, name = \"sa3\", value = \"city_complexity\")) |> \n    inner_join(enframe(complexity$activity, name = \"industry_occupation\", value = \"activity_complexity\"))\n  return(df.complexity)\n}\n```\n:::\n\n\n\n\n\n\n## Results\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#|\nm <- pow_clean |> \n  pivot_wider(id_cols = sa3,\n              names_from = industry_occupation,\n              values_from = count) |> \n  column_to_rownames(var = \"sa3\") |> \n  as.matrix()\n\ncomplexity.df <- complexity_nz(m, base_data = pow_clean)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nmost complex activity: Professional, Scientific and Technical Services (Professionals)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nmost complex city: Brisbane Inner\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nJoining with `by = join_by(sa3)`\nJoining with `by = join_by(industry_occupation)`\n```\n\n\n:::\n:::\n\n\n\n\n\n\n@fig-gcc-complexity shows the regional complexity of SA3 regions in Australian Greater Capital City Areas based on 2021 Census data. Complexity is highest in capital cities and surrounding regions.\n\n\n\n\n\n\n::: {#cell-fig-gcc-complexity .cell}\n\n```{.r .cell-code .hidden}\ncity_complexity <- complexity.df |> \n  distinct(sa3, city_complexity) |> \n  left_join(read_absmap(\"sa32021\",\n                        export_dir = \"data\"),\n            by = c(\"sa3\" = \"sa3_name_2021\")) |> \n  st_as_sf()\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nReading sa32021 file found in data\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\ncity_complexity |> \n  filter(str_detect(gcc_name_2021, \"Australian Capital Territory|Greater\")) |> \n  tm_shape() +\n  tm_polygons(\"city_complexity\") +\n  tm_facets(\"gcc_name_2021\")\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n[scale] tm_polygons:() the data variable assigned to 'fill' contains positive and negative values, so midpoint is set to 0. Set 'midpoint = NA' in 'fill.scale = tm_scale_intervals(<HERE>)' to use all visual values (e.g. colors)\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Complexity of Australian Greater Capital City Areas](index_files/figure-docx/fig-gcc-complexity-1.png){#fig-gcc-complexity}\n:::\n:::\n\n\n\n\n\n\n### Spatial Correlation\n\n-   Is economic complexity correlated across space?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# first find the neighbours (using adacency)\nnb <- poly2nb(city_complexity, queen = TRUE)\nlw <- nb2listw(nb, style = \"W\", zero.policy = TRUE)\n\nmoranI <- moran(city_complexity$city_complexity, listw = lw, n = length(nb), S0 = Szero(lw))\n\nmoranIp <- moran.mc(city_complexity$city_complexity, lw, nsim = 1000)\n```\n:::\n\n\n\n\n\n\n-   Global Moran's I = 0.5007756 with a p.value of 0.\n\n\n\n\n\n\n::: {#cell-fig-complexity-hot-spots .cell}\n\n```{.r .cell-code .hidden}\nMC.i <- localmoran_perm(city_complexity$city_complexity, lw, nsim = 9999) \n\nMC.i.df <- MC.i |> \n  as.data.frame() \n\ncity_complexity$p <- MC.i.df$`Pr(folded) Sim`\ncity_complexity$Ii <- hotspot(MC.i, \n                              Prname = \"Pr(folded) Sim\", \n                              cutoff = 0.05, \n                              p.adjust = \"fdr\")\ncity_complexity$Ii <- factor(city_complexity$Ii, \n                             levels = c(\"High-High\",\n                                        \"Low-Low\",\n                                        \"Low-High\", \n                                        \"High-Low\",\n                                        \">0.05\"))\ncity_complexity$Ii[is.na(city_complexity$Ii)] <- \">0.05\"\n\npal2 <- c( \"#FF0000\", \"#0000FF\", \"#a7adf9\", \"#f4ada8\",\"#ededed\")\n\ntm_shape(city_complexity) + \n  tm_polygons(fill = \"Ii\",\n              fill.scale = tm_scale_categorical(values = pal2),\n              fill.legend = tm_legend(outside = TRUE, \n                                      text.size = 0.8),\n              col = \"grey80\",\n              lwd = 0.5) +\n  tm_layout(frame = FALSE) + \n  tm_facets(by = \"gcc_name_2021\")\n```\n\n::: {.cell-output-display}\n![City Complexity hot spots (based on local Moran's I p.values)](index_files/figure-docx/fig-complexity-hot-spots-1.png){#fig-complexity-hot-spots}\n:::\n:::\n\n\n\n\n\n\n## Conclusion\n\n## References {.unnumbered}\n\n::: {#refs}\n:::\n",
    "supporting": [
      "index_files\\figure-docx"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}